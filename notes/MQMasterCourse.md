# Message Queue Lecture Notes

00

从系统之间有了通信需求开始，就产生了消息队列。它的应用场景非常广泛，比如分布式系统中的进程间通信问题。



__由浅入深地学习消息队列__

浅：使用层面。深：设计思想、实现原理和使用的底层技术。

- 了解消息的基本概念，如主题、订阅、分区等。这些基础概念就像我们学习一门编程语言中的基础语法一样。
- 掌握使用消息队列的技能，能够处理一些常见的问题。
- 必备的底层技术，如高性能的网络传输、内存的管理和锁的使用；
- 高级特性的实现原理，比如如何实现事务消息、消息队列如何支撑海量的IoT设备同时在线。

学习MQ的知识，最后一定要付诸实践，也就是落到代码层面上去操作执行。



### 02 MQ技术选型

三大MQ

1. RabbitMQ
2. RocketMQ
3. Kafka

### 03 消息模型

每种消息队列都有自己的一套消息模型，像Queue、Topic or Partition(分区)这些名词概念，含义还都不太一样。

之所以出现这种情况，是因为MQ没有标准。尽管早期有一些JMS和AMQP这种标准，但标准的进化速度也跟不上MQ的演进速度，这些标准实际已经被放弃了。

#### 主题和队列的区别

__消息队列的演进__

> “好的架构不是设计出来的，而是演进出来的。”
>
> 现代消息队列呈现出的模式，一样也是经过十几年逐步演进而来的。

最初的消息队列，就是一个严格意义上的队列。最初的一种消息模型：队列模型。

只有FIFO，尽管可以多个Producer生产消息进一个队列里，但是队列里的一个消息只能被一个Consumer消费。即这些Consumer间是竞争关系。

如果想要多个消费者都能收到全量的消息，单个队列就满足不了需求。只能为每个Consumer创建一个单独的队列，让Producer发送多份。这显然不仅会浪费资源，More important是这样做Producer必须要知道有多少个Consumer，这实际上违背了MQ"解耦"的设计初衷。

为了解决这个问题，演化出了另外一种消息模型：”Publish-Subscribe Pattern“(发布-订阅模型)



现代MQ大多数使用的消息模型就是发布订阅模型，当然也有例外--RabbitMQ

__RabbitMQ的消息模型__

少数依然坚持使用队列模型的MQ。
那它是如何解决多Consumer的问题呢？

Exchange模块，在RabbitMQ中，Exchange位于Producer和Queue之间，Producer并不关心将消息发送给哪个Queue，而是将消息发送给Exchange，由Exchange上配置的策略来决定将消息投递到那些Queue中。

__RocketMQ的消息模型__

标准的发布订阅模型，重点是队列

__Kafka的消息模型__

与RocketMQ完全一致，唯一区别就是队列这个概念的名称不一样，Kafka中对应的名称是"Partition(分区)"，含义和功能是没有任何区别的。

































