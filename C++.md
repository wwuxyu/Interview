


# cpp
ref
https://www.stibel.icu/md/c++/features/c14/c++-features-c14.html




# Key-Words

## inline

### 什么函数可以inline？

inline可以用来修饰virtual吗？



## explicit

用来声明类构造函数是显式调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换和赋值初始化。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显式调用的，再加上 explicit 关键字也没有什么意义。

## static

### 函数内声明静态变量

```cpp
void CustomerOpConvertPass::customerOpCvt(Operation *op) {
  static pthread_mutex_t mutex;
  static int pythonFlag = 0;
}
```

如pythonFlag这个变量，因为函数要执行多次，同时保留上次flag的记录，所以将用static修饰。写成全局变量也是可以的。


### 静态成员变量初始化
静态数据成员不能在类中初始化，一般在类外和 main() 函数之前初始化，缺省时初始化为 0。
1. 静态成员不能在类定义里边初始化，只能在 class body 外初始化。
2. static成员的所有者是类本身，但是多个对象拥有一样的静态成员。故其不能在实例化对象时通过构造函数对其进行初始化。
3. 静态成员仍然遵循 public，private，protected 访问准则。
4. 静态成员函数没有 this 指针，它不能返回非静态成员，因为除了对象会调用它外，类本身也可以调用
5. 静态成员属于全局变量，是所有实例化以后的对象所共享的，而成员的初始化你可以想象成向系统申请内存存储数据的过程，显然这种共有对象。不能在任何函数和局部作用域中初始化。

--静态成员属于全局变量，是所有实例化以后的对象所共享的，而成员的初始化你可以想象成向系统申请内存存储数据的过程，显然这种共有对象。不能在任何函数和局部作用域中初始化。--

GPT:
因为静态成员变量是类的一部分，而不是对象的一部分。因此，它的类型必须在类定义的外部进行指定。

在类内部声明静态成员变量时，只是它的声明，不分配存储空间，因此不涉及初始化。初始化工作必须在类的外部进行，通常在类的实现文件（.cpp 文件）中。此时需要指定类型，以确保编译器能够正确分配存储空间和进行相关的初始化工作。


```c++
class point{
public:
	point(){};
//	...
private:
	static int x,y;
};
int point::x = 0;
int point::y = 0;
 
int main(){
//	...
}
```

## const
### 常量指针(指向常量的指针)和指针常量
__常量指针(指向常量的指针)__
定义：具有只能够读取内存中数据，却不能够修改内存中数据的属性的指针，称为指向常量的指针，简称常量指针。


声明：`const int * p`; `int const * p`;

__指针常量__
指针常量是指指针所指向的位置不能改变，即指针本身是一个常量，但是指针所指向的内容可以改变。 `int * const p=&a`;

注：指针常量必须在声明的同时对其初始化，不允许先声明一个指针常量随后再对其赋值，这和声明一般的常量是一样的

区分，看const在*的左边还是右边，左边即为指向常量的指针，右边即为指针常量。


用const修饰的常量只能由常量指针指向，普通指针不可以指向常量。
```c++
    const int c = 1;
    //int * pc = &c; error
    const int * pc = &c;
```
## constexpr

## explicit 
explicit关键字主要是用来修饰类中的构造函数的，对于仅有一个参数或除第一个参数外其余参数均有默认值的类构造函数，尽可能使用explicit关键字修饰。因为只有一个参数或者出了第一个参数其他参数是默认参数的构造函数来说，他还有另一个名字叫做转换构造函数。

**所以explicit主要用来防止隐式转换**.因为仅含一个参数的构造函数和除了第一个参数外其余参数都有默认值的多参构造函数承担了两个角色。 第一个是成为带参数的构造函数，第二个是一个默认且隐含的类型转换操作符（就是单参数的构造函数是一种隐含的类型转换符）

额外说一下隐式类型转换：

c++隐式类型转换是指c++自动将一种类型转换成另一种类型，是编译器的一种自主行为。

举一些类型转换的例子：


# STL
# STL Container 线程安全
__vector__



# C++11

# C++14
C++14是对C++11的补充,并没有太多新特性。
https://github.com/AnthonyCalandra/modern-cpp-features

[翻译](https://cloud.tencent.com/developer/article/1670712)

__新特性一览__

**语言新特性**
- 二进制字面值
- 泛型的Lambda表达式
- 初始化Lambda的捕获列表
- 推断返回类型
- decltype(auto)
- 放宽对常量表达式函数的约束
- 变量模板
- [[deprecated]]属性

**标准库新特性**
- 可用于标准库类型的自定义字面量
- 编译期的整型序列
- std::make_unique

# C++17
https://zhuanlan.zhihu.com/p/165640868

构造函数模板推导
结构化绑定
if-switch语句初始化
内联变量
折叠表达式
constexpr lambda表达式
namespace嵌套
__has_include预处理表达式
在lambda表达式用*this捕获对象副本
新增Attribute
字符串转换
std::variant
std::optional
std::any
std::apply
std::make_from_tuple
as_const
std::string_view
file_system
std::shared_mutex



## 语言基础
### 声明、定义和初始化

变量

1. 声明：是指出存储类型，并给存储单元指定名称。

2. 定义：是分配内存空间，还可为变量指定初始值。

3. extern 关键字：通过使用 extern 关键字声明变量名，而不是定义它。

注：

1. 声明不一定是定义：extern 声明没有分配内存空间，所以不是定义；extern 告诉编译器变量在其他地方定义了。

例如：extern int val; // 只是声明了变量 val，并没有分配内存空间，所以不是定义。

2. 定义也是声明：定义变量的时候，同时给变量指出了存储类型，并给变量的存储单元指定了名称，所以也是声明。

例如：int val; // 声明了变量 val，也会分配内存空间，所以也是定义。

3. extern 关键字标识的才是声明，其余都是定义

例如：extern int val; // 声明

int val; // 定义

4. 声明有指定初始值：如果指定了初始值，即使前面加了 extern 关键字，也是定义。

例如：extern int val = 1; // 定义

5. 一个变量的定义永远只能有一个，但是可以有多个声明。

函数

1. 函数原型（又称函数声明）：函数原型之于函数，相当于变量声明之于变量，只有函数头的就是函数原型。

例如：int function();

extern int function();

2. 函数定义：带有函数体的就是定义，

例如：int function() { return 0;}

注：

1. 函数原型的返回值类型与函数定义必须相同。

2. 函数原型的形参表的类型与顺序必须与函数定义相同，但是函数原型可以不写形参名称，即便写了形参名称也可以和原函数不一样。

3. 空形参

C 语言中：

int func(); // 表示可以有很多个参数

int func(void); // 表示没有参数

C++ 中，上述两行代码等价，且都表示没有参数。

4. 在函数被调用之前必须先有函数原型，函数定义可以放在调用函数的后面。

int func(); // 必须在调用函数的前面

int main() { int ret = func(); }

int func() { return 0;} 可以在调用函数的后

5. 函数原型描述了函数接口，即函数如何与程序的其他部分交互。参数列表指出了何种信息将被传递给函数，函数类型指出了返回值的类型。







